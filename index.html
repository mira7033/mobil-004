<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ëª¨ë°”ì¼ ì‹¤ì‹œê°„ ê°ì²´ ì¸ì‹</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <style>
        body {
            background-color: #f8f9fa;
            padding-top: 1rem;
            padding-bottom: 1rem;
        }
        #video-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            background-color: #000;
        }
        #video-container::before {
            content: "";
            display: block;
            padding-top: 75%; /* 4:3 Aspect Ratio */
        }
        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

    <div class="container text-center">

        <h1 class="h3 fw-bold mt-2">ê°ì²´ ì¸ì‹ ë° ìŒì„± ì•ˆë‚´ ğŸ“·ğŸ”Š</h1>
        <p class="mb-3">ìŠ¤ë§ˆíŠ¸í° í›„ë©´ ì¹´ë©”ë¼ë¡œ ì‚¬ë¬¼ì„ ë¹„ì¶°ë³´ì„¸ìš”.</p>

        <div id="status" class="alert alert-info mx-auto" role="alert">
            ëª¨ë¸ì„ ë¡œë”© ì¤‘ì…ë‹ˆë‹¤...
        </div>

        <div id="video-container" class="shadow-sm rounded overflow-hidden mb-3">
            <video id="webcam" autoplay muted playsinline></video>
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@latest/dist/coco-ssd.min.js"></script>

    <script>
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const statusDiv = document.getElementById('status');
        const ctx = canvas.getContext('2d');

        let model = undefined;
        let previouslyDetected = new Set();

        function speak(text) {
            if (speechSynthesis.speaking) return;
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'ko-KR';
            utterance.rate = 1.2;
            speechSynthesis.speak(utterance);
        }

        // ëª¨ë°”ì¼ ì•ˆì •ì„±ì„ ê°•í™”í•œ ì›¹ìº  ì„¤ì • í•¨ìˆ˜
        async function setupWebcam() {
            return new Promise((resolve, reject) => {
                const constraints = {
                    video: {
                        facingMode: 'environment' // í›„ë©´ ì¹´ë©”ë¼ ìš°ì„ 
                    }
                };
                navigator.mediaDevices.getUserMedia(constraints)
                    .then(stream => {
                        video.srcObject = stream;
                        video.addEventListener('loadeddata', resolve);
                    })
                    .catch(err => {
                        console.warn('í›„ë©´ ì¹´ë©”ë¼ ì‹¤íŒ¨. ì „ë©´ ì¹´ë©”ë¼ë¡œ ì¬ì‹œë„.');
                        constraints.video.facingMode = 'user'; // ì „ë©´ ì¹´ë©”ë¼ë¡œ ì¬ì‹œë„
                        navigator.mediaDevices.getUserMedia(constraints)
                            .then(stream => {
                                video.srcObject = stream;
                                video.addEventListener('loadeddata', resolve);
                            })
                            .catch(reject);
                    });
            });
        }

        async function predict() {
            if (model && video.readyState >= 3) { // ëª¨ë¸ê³¼ ë¹„ë””ì˜¤ê°€ ì¤€ë¹„ë˜ì—ˆì„ ë•Œë§Œ ì‹¤í–‰
                const predictions = await model.detect(video);

                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = '16px Arial';
                ctx.textBaseline = 'top';

                const currentDetections = new Set();
                predictions.forEach(prediction => {
                    const objectName = prediction.class;
                    currentDetections.add(objectName);

                    if (!previouslyDetected.has(objectName)) {
                        speak(objectName);
                    }
                    
                    const [x, y, width, height] = prediction.bbox;
                    const label = `${objectName} (${Math.round(prediction.score * 100)}%)`;
                    
                    ctx.strokeStyle = '#00FFFF';
                    ctx.lineWidth = 2.5;
                    ctx.strokeRect(x, y, width, height);
                    
                    ctx.fillStyle = '#00FFFF';
                    const textWidth = ctx.measureText(label).width;
                    ctx.fillRect(x, y, textWidth + 8, 22);
                    
                    ctx.fillStyle = '#000000';
                    ctx.fillText(label, x + 4, y + 2);
                });
                previouslyDetected = currentDetections;
            }
            requestAnimationFrame(predict);
        }
        
        async function run() {
            try {
                statusDiv.innerText = 'ì¹´ë©”ë¼ ê¶Œí•œì„ í™•ì¸í•´ì£¼ì„¸ìš”...';
                await setupWebcam();
                statusDiv.innerText = 'ì¹´ë©”ë¼ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.';
                statusDiv.classList.replace('alert-info', 'alert-success');
            } catch (e) {
                console.error(e);
                statusDiv.innerText = 'ì¹´ë©”ë¼ë¥¼ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê¶Œí•œì„ í™•ì¸í•´ì£¼ì„¸ìš”.';
                statusDiv.classList.replace('alert-info', 'alert-danger');
                return;
            }

            try {
                statusDiv.innerText = 'ê°ì²´ ì¸ì‹ ëª¨ë¸ì„ ë¡œë”©í•©ë‹ˆë‹¤...';
                statusDiv.classList.replace('alert-success', 'alert-info');
                model = await cocoSsd.load();
                statusDiv.innerText = 'ëª¨ë¸ ë¡œë”© ì™„ë£Œ! ì¸ì‹ì„ ì‹œì‘í•©ë‹ˆë‹¤.';
                statusDiv.classList.replace('alert-info', 'alert-success');
                predict();
            } catch (e) {
                console.error(e);
                statusDiv.innerText = 'ëª¨ë¸ ë¡œë”©ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë„¤íŠ¸ì›Œí¬ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.';
                statusDiv.classList.replace('alert-info', 'alert-danger');
            }
        }
        run();
    </script>
</body>
</html>